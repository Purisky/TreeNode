using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using TreeNodeSourceGenerator;

namespace TreeNodeSourceGenerator
{
    public partial class NodeAccessorSourceGenerator
    {
        private enum AccessOperation
        {
            Get,
            Set,
            Remove,
            ValidatePath,
        }
        private string GeneratePropertyAccessorPartialClass(INamedTypeSymbol nodeType, List<AccessibleMemberInfo> accessibleMembers)
        {
            var className = nodeType.Name;
            var namespaceName = nodeType.ContainingNamespace.ToDisplayString();
            var sb = new StringBuilder();
            
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Linq;");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine("using TreeNode.Runtime;");
            sb.AppendLine("using TreeNode.Utility;");
            sb.AppendLine();
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            
            string typeKeyword = nodeType.TypeKind == TypeKind.Struct ? "struct" : "class";
            sb.AppendLine($"    public partial {typeKeyword} {className} : IPropertyAccessor");
            sb.AppendLine("    {");

            GenerateAccessMethod(sb, nodeType, accessibleMembers, AccessOperation.Get);
            GenerateAccessMethod(sb, nodeType, accessibleMembers, AccessOperation.Set);
            GenerateAccessMethod(sb, nodeType, accessibleMembers, AccessOperation.Remove);
            GenerateAccessMethod(sb, nodeType, accessibleMembers, AccessOperation.ValidatePath);

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private void GenerateAccessMethod(StringBuilder sb, INamedTypeSymbol nodeType, List<AccessibleMemberInfo> members, AccessOperation operation)
        {
            var methodInfo = GetMethodInfo(operation, nodeType.Name);
            string override_keyword = ImplementsIPropertyAccessor(nodeType) ? "override " : "";
            sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        public {override_keyword}{methodInfo.ReturnType}");
            sb.AppendLine("        {");
            
            if (operation == AccessOperation.ValidatePath)
            {
                GenerateValidatePathMethod(sb, members);
                sb.AppendLine("        }");
                sb.AppendLine();
                return;
            }
            
            if (members.Count == 0)
            {
                sb.AppendLine($"            {methodInfo.EmptyHandling}");
                sb.AppendLine("        }");
                return;
            }

            sb.AppendLine("            ref PAPart first =ref path.Parts[index];");

            sb.AppendLine($"            if (first.IsIndex) {{ {methodInfo.IndexErrorHandling} }}");

            sb.AppendLine("            if (index == path.Parts.Length - 1)");

            sb.AppendLine("            {");
            GenerateSinglePathLogic(sb, members, operation);
            sb.AppendLine("            }");
            sb.AppendLine("            index++;");
            GenerateMultiPathLogic(sb, members, operation);

            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private (string ReturnType,  string EmptyHandling, string IndexErrorHandling) GetMethodInfo(AccessOperation operation, string nodeTypeName)
        {
            return operation switch
            {
                AccessOperation.Get => (
                    "T GetValueInternal<T>(ref PAPath path,ref int index)",
                    "throw new NotSupportedException(\"No readable properties or fields available for getting value.\");",
                    $"throw new NotSupportedException($\"Index access not supported by {nodeTypeName}\");"
                ),
                AccessOperation.Set => (
                    "void SetValueInternal<T>(ref PAPath path,ref int index, T value)",
                    "throw new NotSupportedException(\"No writable properties or fields available for setting value.\");",
                    $"throw new NotSupportedException($\"Index access not supported by {nodeTypeName}\");"
                ),
                AccessOperation.Remove => (
                    "void RemoveValueInternal(ref PAPath path,ref int index)",
                    "throw new NotSupportedException(\"No removable properties or fields available for removing value.\");",
                    $"throw new NotSupportedException($\"Index access not supported by {nodeTypeName}\");"
                ),
                AccessOperation.ValidatePath => (
                    "void ValidatePath(ref PAPath path,ref int index)",
                    "// No validation needed for empty type",
                    "// Index access validation not needed for ValidatePath"
                ),
                _ => throw new ArgumentException($"Unknown operation: {operation}")
            };
        }

        private void GenerateSinglePathLogic(StringBuilder sb, List<AccessibleMemberInfo> members, AccessOperation operation)
        {
            var targetMembers = operation == AccessOperation.Set || operation == AccessOperation.Remove
                ? members.Where(m => m.CanWrite && !m.IsReadOnly).ToList()
                : members;

            if (!targetMembers.Any()) return;

            sb.AppendLine("                switch (first.Name)");
            sb.AppendLine("                {");

            foreach (var member in targetMembers)
            {
                sb.AppendLine($"                    case \"{member.Name}\":");
                if (operation != AccessOperation.Remove)
                {
                    GenerateInstanceCreationIfNeeded(sb, member);
                }
                GenerateSinglePathMemberAccess(sb, member, operation);
            }

            sb.AppendLine("                    default:");
            sb.AppendLine($"                        {GetSinglePathDefaultCase(operation)}");
            sb.AppendLine("                }");
        }

        private void GenerateMultiPathLogic(StringBuilder sb, List<AccessibleMemberInfo> members, AccessOperation operation)
        {
            var multiPathMembers = operation == AccessOperation.Set || operation == AccessOperation.Remove
                ? members.Where(m => (m.HasNestedAccess || m.IsCollection) && m.CanWrite && !m.IsReadOnly).ToList()
                : members.Where(m => m.HasNestedAccess || m.IsCollection).ToList();

            if (!multiPathMembers.Any())
            {
                if (members.Any())
                {
                    sb.AppendLine($"            {GetMultiPathEmptyHandling(operation)}");
                }
                return;
            }

            sb.AppendLine("            switch (first.Name)");
            sb.AppendLine("            {");

            foreach (var member in multiPathMembers)
            {
                sb.AppendLine($"                case \"{member.Name}\":");
                GenerateMultiPathMemberAccess(sb, member, operation);
            }

            sb.AppendLine("                default:");
            sb.AppendLine($"                    {GetMultiPathDefaultCase(operation)}");
            sb.AppendLine("            }");
        }

        private void GenerateInstanceCreationIfNeeded(StringBuilder sb, AccessibleMemberInfo member)
        {
            if (NeedCreateInstance(member))
            {
                sb.AppendLine($"                    {member.Name}??=new();");
            }
        }

        private void GenerateSinglePathMemberAccess(StringBuilder sb, AccessibleMemberInfo member, AccessOperation operation)
        {
            switch (operation)
            {
                case AccessOperation.Get:
                    sb.AppendLine($"                        return ({member.Name} is T _{member.Name}) ? _{member.Name} : default(T);");
                    break;
                case AccessOperation.Set:
                    sb.AppendLine($"                        if (value is {member.Type.ToDisplayString()} _{member.Name}) {{ {member.Name} = _{member.Name}; return; }}");
                    sb.AppendLine($"                        throw new InvalidCastException($\"Cannot cast {{typeof(T).Name}} to {member.Type.ToDisplayString()}\");");
                    break;
                case AccessOperation.Remove:
                    if (member.IsValueType)
                    {
                        sb.AppendLine($"                        {member.Name} = default({member.Type.ToDisplayString()}); return;");
                    }
                    else
                    {
                        sb.AppendLine($"                        {member.Name} = null; return;");
                    }
                    break;
            }
        }

        private void GenerateMultiPathMemberAccess(StringBuilder sb, AccessibleMemberInfo member, AccessOperation operation)
        {
            if (member.IsCollection)
            {
                GenerateInstanceCreationIfNeeded(sb, member);
                GenerateCollectionAccess(sb, member, operation);
            }
            else if (member.HasNestedAccess)
            {
                GenerateNestedAccess(sb, member, operation);
            }
        }

        private void GenerateCollectionAccess(StringBuilder sb, AccessibleMemberInfo member, AccessOperation operation)
        {
            var accessMethod = operation switch
            {
                AccessOperation.Get => $"return {member.Name}.GetValueInternal<T>(ref path,ref index);",
                AccessOperation.Set when member.IsStructCollection => 
                    $"{member.Name}.SetValueInternalStruct(ref path,ref index, value);return;",
                AccessOperation.Set => 
                    $"{member.Name}.SetValueInternalClass(ref path,ref index, value);return;",
                AccessOperation.Remove  when member.IsStructCollection =>
                    $"{member.Name}.RemoveValueInternalStruct(ref path,ref index);return;",
                AccessOperation.Remove =>
                    $"{member.Name}.RemoveValueInternalClass(ref path,ref index);return;",
                _ => throw new ArgumentException($"Unknown operation: {operation}")
            };

            sb.AppendLine($"                    {accessMethod}");
        }

        private void GenerateNestedAccess(StringBuilder sb, AccessibleMemberInfo member, AccessOperation operation)
        {
            bool needCreateInstance = NeedCreateInstance(member);
            if (needCreateInstance && operation != AccessOperation.Remove)
            {
                sb.AppendLine($"                        {member.Name}??=new();");
            }

            bool structProperty = member.IsValueType && member.IsProperty && (operation is AccessOperation.Set or AccessOperation.Remove);

            if (structProperty)
            {
                // 对于 struct 属性，需要通过临时变量进行操作
                sb.AppendLine($"                    var temp_{member.Name} = {member.Name};");

                var accessMethod = GetNestedAccessMethodForStruct(member, operation, $"temp_{member.Name}");
                sb.AppendLine($"                    {accessMethod}");
                sb.AppendLine($"                    {member.Name} = temp_{member.Name};");
                sb.AppendLine($"                    return;");
            }
            else
            {
                var accessMethod = GetNestedAccessMethod(member, operation);

                string nullCheck = (member.IsValueType || needCreateInstance)
                    ? accessMethod
                    : $"if ({member.Name} != null) {{ {accessMethod} }}";

                sb.AppendLine($"                    {nullCheck}");

                if (!member.IsValueType && !needCreateInstance)
                {
                    sb.AppendLine($"                    throw new NullReferenceException($\"{member.Name} is null\");");
                }
            }
        }

        private string GetNestedAccessMethod(AccessibleMemberInfo member, AccessOperation operation)
        {
            var directAccess = operation switch
            {
                AccessOperation.Get => $"return {member.Name}.GetValueInternal<T>(ref path,ref index);",
                AccessOperation.Set => $"{member.Name}.SetValueInternal<T>(ref path,ref index, value);return;",
                AccessOperation.Remove => $"{member.Name}.RemoveValueInternal(ref path,ref index);return;",
                _ => throw new ArgumentException($"Unknown operation: {operation}")
            };

            var propertyAccessorAccess = operation switch
            {
                AccessOperation.Get => $"return PropertyAccessor.GetValue<T>({member.Name}, ref path,ref index);",
                AccessOperation.Set => $"PropertyAccessor.SetValue({member.Name},ref path,ref index, value);return;",
                AccessOperation.Remove => $"PropertyAccessor.RemoveValue({member.Name},ref path,ref index);return;",
                _ => throw new ArgumentException($"Unknown operation: {operation}")
            };
            return member.ImplementsIPropertyAccessor||member.IsJsonNodeType||(member.Type is INamedTypeSymbol namedTypeSymbol&& TypeDict.ContainsKey(namedTypeSymbol)) ? directAccess : propertyAccessorAccess;
        }

        private string GetNestedAccessMethodForStruct(AccessibleMemberInfo member, AccessOperation operation, string tempVarName)
        {
            var directAccess = operation switch
            {
                AccessOperation.Get => $"return {tempVarName}.GetValueInternal<T>(ref path,ref index);",
                AccessOperation.Set => $"{tempVarName}.SetValueInternal<T>(ref path,ref index, value);",
                AccessOperation.Remove => $"{tempVarName}.RemoveValueInternal(ref path,ref index);",
                _ => throw new ArgumentException($"Unknown operation: {operation}")
            };

            var propertyAccessorAccess = operation switch
            {
                AccessOperation.Get => $"return PropertyAccessor.GetValue<T>({tempVarName}, ref path,ref index);",
                AccessOperation.Set => $"PropertyAccessor.SetValue({tempVarName},ref path,ref index, value);",
                AccessOperation.Remove => $"PropertyAccessor.RemoveValue({tempVarName},ref path,ref index);",
                _ => throw new ArgumentException($"Unknown operation: {operation}")
            };
            
            return member.ImplementsIPropertyAccessor||member.IsJsonNodeType||(member.Type is INamedTypeSymbol namedTypeSymbol&& TypeDict.ContainsKey(namedTypeSymbol)) ? directAccess : propertyAccessorAccess;
        }

        private string GetSinglePathDefaultCase(AccessOperation operation)
        {
            return operation switch
            {
                AccessOperation.Get => "throw new NotSupportedException($\"Property '{first.Name}' not found\");",
                AccessOperation.Set => "throw new NotSupportedException($\"Property '{first.Name}' not found or not writable\");",
                AccessOperation.Remove => "throw new NotSupportedException($\"Property '{first.Name}' not found or not removable\");",
                _ => throw new ArgumentException($"Unknown operation: {operation}")
            };
        }

        private string GetMultiPathDefaultCase(AccessOperation operation)
        {
            return operation switch
            {
                AccessOperation.Get => "throw new NotSupportedException($\"Path starting with '{first.Name}' not supported\");",
                AccessOperation.Set => "throw new NotSupportedException($\"Path starting with '{first.Name}' not supported or not writable\");",
                AccessOperation.Remove => "throw new NotSupportedException($\"Path starting with '{first.Name}' not supported or not removable\");",
                _ => throw new ArgumentException($"Unknown operation: {operation}")
            };
        }

        private string GetMultiPathEmptyHandling(AccessOperation operation)
        {
            return operation switch
            {
                AccessOperation.Get => "throw new NotSupportedException(\"No multi-path properties or fields available for getting value.\");",
                AccessOperation.Set => "throw new NotSupportedException(\"No multi-path properties or fields available for setting value.\");",
                AccessOperation.Remove => "throw new NotSupportedException(\"No multi-path properties or fields available for removing value.\");",
                _ => throw new ArgumentException($"Unknown operation: {operation}")
            };
        }

        private void GenerateValidatePathMethod(StringBuilder sb, List<AccessibleMemberInfo> members)
        {
            sb.AppendLine("            ref PAPart part = ref path.Parts[index];");
            sb.AppendLine("            if (part.IsIndex)");
            sb.AppendLine("            {");
            sb.AppendLine("                index--;");
            sb.AppendLine("                return;");
            sb.AppendLine("            }");
            sb.AppendLine();
            
            if (members.Count == 0)
            {
                sb.AppendLine("            index--;");
                sb.AppendLine("            return;");
                return;
            }

            sb.AppendLine("            switch (part.Name)");
            sb.AppendLine("            {");

            // 先处理终端字段（基础类型），无论单路径还是多路径都是有效的终点
            var terminalMembers = members.Where(m => !(m.HasNestedAccess || m.IsCollection)).ToList();
            if (terminalMembers.Any())
            {
                foreach (var member in terminalMembers)
                {
                    sb.AppendLine($"                case \"{member.Name}\":");
                }
                sb.AppendLine("                    return;");  // 终端字段，路径有效
            }

            // 处理需要null检查的嵌套类型字段
            var nestedMembers = members.Where(m => m.HasNestedAccess || m.IsCollection).ToList();
            foreach (var member in nestedMembers)
            {
                sb.AppendLine($"                case \"{member.Name}\":");
                
                // 先进行null检查（对于不会自动创建且是引用类型的成员）
                bool needCreateInstance = NeedCreateInstance(member);
                if (!member.IsValueType && !needCreateInstance)
                {
                    sb.AppendLine($"                    if ({member.Name} == null){{index--;return;}}");
                }
                
                // 然后进行单路径判断
                sb.AppendLine("                    if (index == path.Parts.Length - 1){return;}");
                
                // 最后是多路径递归验证
                sb.AppendLine("                    index++;");
                
                if (member.IsCollection)
                {
                    if (member.ImplementsIPropertyAccessor || member.IsJsonNodeType || (member.Type is INamedTypeSymbol namedTypeSymbol && TypeDict.ContainsKey(namedTypeSymbol)))
                    {
                        sb.AppendLine($"                    {member.Name}.ValidatePath(ref path, ref index);");
                    }
                    else
                    {
                        sb.AppendLine($"                    {member.Name}.ValidatePath(ref path, ref index);");
                    }
                    sb.AppendLine("                    return;");
                }
                else // member.HasNestedAccess
                {
                    if (member.ImplementsIPropertyAccessor || member.IsJsonNodeType || (member.Type is INamedTypeSymbol namedTypeSymbol2 && TypeDict.ContainsKey(namedTypeSymbol2)))
                    {
                        sb.AppendLine($"                    {member.Name}.ValidatePath(ref path, ref index);");
                    }
                    else
                    {
                        sb.AppendLine($"                    PropertyAccessor.ValidatePath({member.Name}, ref path, ref index);");
                    }
                    sb.AppendLine("                    return;");
                }
            }

            sb.AppendLine("                default:");
            sb.AppendLine("                    index--;");  // 属性不存在，路径无效
            sb.AppendLine("                    return;");
            sb.AppendLine("            }");
        }
    }
}