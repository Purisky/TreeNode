using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using TreeNodeSourceGenerator;
namespace TreeNodeSourceGenerator
{
    public partial class NodeAccessorSourceGenerator
    {
        private string GeneratePropertyAccessorPartialClass(INamedTypeSymbol nodeType)
        {
            var className = nodeType.Name;
            var namespaceName = nodeType.ContainingNamespace.ToDisplayString();
            var accessibleMembers = AnalyzeAccessibleMembers(nodeType);

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Linq;");
            sb.AppendLine("using TreeNode.Runtime;");
            sb.AppendLine("using TreeNode.Utility;");
            sb.AppendLine();
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            sb.AppendLine($"    public partial class {className} : IPropertyAccessor");
            sb.AppendLine("    {");

            GenerateGetValueInternalMethod(sb, nodeType, accessibleMembers);
            GenerateSetValueInternalMethod(sb, nodeType, accessibleMembers);

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }
        private List<AccessibleMemberInfo> AnalyzeAccessibleMembers(INamedTypeSymbol nodeType)
        {
            var members = new List<AccessibleMemberInfo>();

            foreach (var member in nodeType.GetMembers())
            {
                if (member is IFieldSymbol field && field.DeclaredAccessibility == Accessibility.Public)
                {
                    var memberInfo = AnalyzeFieldMember(field);
                    if (!memberInfo.IsReadOnly && (memberInfo.IsJsonNodeType || memberInfo.ImplementsIPropertyAccessor || memberInfo.HasNestedAccess))
                    {
                        members.Add(memberInfo);
                    }
                }
                else if (member is IPropertySymbol property &&
                         property.DeclaredAccessibility == Accessibility.Public &&
                         property.GetMethod != null)
                {
                    var memberInfo = AnalyzePropertyMember(property);
                    if (!memberInfo.IsReadOnly && (memberInfo.IsJsonNodeType || memberInfo.ImplementsIPropertyAccessor || memberInfo.HasNestedAccess))
                    {
                        members.Add(memberInfo);
                    }
                }
            }

            return members;
        }

        private AccessibleMemberInfo AnalyzeFieldMember(IFieldSymbol field)
        {
            return new AccessibleMemberInfo
            {
                Name = field.Name,
                Type = field.Type,
                IsValueType = field.Type.IsValueType,
                IsJsonNodeType = IsJsonNodeType(field.Type),
                ImplementsIPropertyAccessor = ImplementsIPropertyAccessor(field.Type),
                HasNestedAccess = HasNestedAccessCapability(field.Type),
                IsCollection = IsCollection(field.Type),
                ElementType = GetCollectionElementType(field.Type),
                CanWrite = !field.IsReadOnly,
                IsReadOnly = field.IsReadOnly,
                IsStructCollection = IsStructCollection(field.Type)
            };
        }

        private AccessibleMemberInfo AnalyzePropertyMember(IPropertySymbol property)
        {
            return new AccessibleMemberInfo
            {
                Name = property.Name,
                Type = property.Type,
                IsValueType = property.Type.IsValueType,
                IsJsonNodeType = IsJsonNodeType(property.Type),
                ImplementsIPropertyAccessor = ImplementsIPropertyAccessor(property.Type),
                HasNestedAccess = HasNestedAccessCapability(property.Type),
                IsCollection = IsCollection(property.Type),
                ElementType = GetCollectionElementType(property.Type),
                CanWrite = property.SetMethod != null,
                IsReadOnly = property.SetMethod == null,
                IsStructCollection = IsStructCollection(property.Type)
            };
        }

        private void GenerateGetValueInternalMethod(StringBuilder sb, INamedTypeSymbol nodeType, List<AccessibleMemberInfo> members)
        {
            sb.AppendLine("        public override T GetValueInternal<T>(PAPath path)");
            if (members.Count == 0)
            {
                sb.AppendLine("            {throw new NotSupportedException(\"No readable properties or fields available for getting value.\");}");
                return;
            }
            sb.AppendLine("        {");
            sb.AppendLine("            PAPart first = path.FirstPart;");
            sb.AppendLine($"            if (first.IsIndex){{throw new NotSupportedException($\"Index access not supported by {nodeType.Name}\");}}");
            sb.AppendLine("            if (path.Parts.Length == 1) {");
            GenerateSinglePathGetterLogic(sb, members);
            sb.AppendLine("            }");
            GenerateMultiPathGetterLogic(sb, members);
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private void GenerateSinglePathGetterLogic(StringBuilder sb, List<AccessibleMemberInfo> members)
        {
            sb.AppendLine("                    switch (first.Name)");
            sb.AppendLine("                    {");

            foreach (var member in members)
            {
                sb.AppendLine($"                        case \"{member.Name}\":");
                sb.AppendLine($"                            return ({member.Name} is T _{member.Name}) ? _{member.Name} : default(T);");
            }
            sb.AppendLine("                        default:");
            sb.AppendLine("                            throw new NotSupportedException($\"Property '{first.Name}' not found\");");
            sb.AppendLine("                    }");
            sb.AppendLine();
        }

        private void GenerateMultiPathGetterLogic(StringBuilder sb, List<AccessibleMemberInfo> members)
        {
            var multiPathMembers = members.Where(m => m.HasNestedAccess || m.IsCollection).ToList();
            if (multiPathMembers.Count == 0) return;

            sb.AppendLine("                    switch (first.Name)");
            sb.AppendLine("                    {");

            foreach (var member in multiPathMembers)
            {
                sb.AppendLine($"                        case \"{member.Name}\":");

                if (member.IsCollection)
                {
                    sb.AppendLine("                            if (path.Parts.Length > 1 && path.Parts[1].IsIndex)");
                    sb.AppendLine("                            {");
                    sb.AppendLine($"                                if ({member.Name} != null && path.Parts[1].Index >= 0 && path.Parts[1].Index < {member.Name}.Count)");
                    sb.AppendLine("                                {");
                    sb.AppendLine($"                                    var item = {member.Name}[path.Parts[1].Index];");
                    sb.AppendLine("                                    if (item != null)");
                    sb.AppendLine("                                    {");
                    sb.AppendLine("                                        if (path.Parts.Length == 2)");
                    sb.AppendLine("                                        {");
                    sb.AppendLine("                                            return (item is T directValue) ? directValue : default(T);");
                    sb.AppendLine("                                        }");
                    sb.AppendLine("                                        else");
                    sb.AppendLine("                                        {");
                    sb.AppendLine("                                            var remainingPath = new PAPath(path.Parts.Skip(2).ToArray());");

                    if (member.ElementType != null && ImplementsIPropertyAccessor(member.ElementType))
                    {
                        sb.AppendLine("                                            return ((IPropertyAccessor)item).GetValueInternal<T>(remainingPath);");
                    }
                    else
                    {
                        sb.AppendLine("                                            return PropertyAccessor.GetValue<T>(item, remainingPath.ToString());");
                    }

                    sb.AppendLine("                                        }");
                    sb.AppendLine("                                    }");
                    sb.AppendLine("                                }");
                    sb.AppendLine("                            }");
                    sb.AppendLine("                            else");
                    sb.AppendLine("                            {");
                    sb.AppendLine($"                                if ({member.Name} != null)");
                    sb.AppendLine("                                {");
                    sb.AppendLine("                                    var remainingPath = new PAPath(path.Parts.Skip(1).ToArray());");
                    sb.AppendLine($"                                    return PropertyAccessor.GetValue<T>({member.Name}, remainingPath.ToString());");
                    sb.AppendLine("                                }");
                    sb.AppendLine("                            }");
                }
                else if (member.HasNestedAccess)
                {
                    if (!member.IsValueType)
                    { 
                        sb.AppendLine($"                            if ({member.Name} != null){{");
                    }
                    if (member.ImplementsIPropertyAccessor)
                    {
                        sb.AppendLine($"                                return {member.Name}.GetValueInternal<T>(path.SkipFirst);");
                    }
                    else
                    {
                        sb.AppendLine($"                                return PropertyAccessor.GetValue<T>({member.Name}, path.SkipFirst);");
                    }
                    if (!member.IsValueType)
                    { 
                    sb.AppendLine($"                            }}throw new NullReferenceException($\"{member.Name} is null\");");
                    }

                }

            }

            sb.AppendLine("                        default:");
            sb.AppendLine("                            throw new NotSupportedException($\"Path starting with '{first.Name}' not supported\");");
            sb.AppendLine("                    }");
            sb.AppendLine();
        }

        private void GenerateSetValueInternalMethod(StringBuilder sb, INamedTypeSymbol nodeType, List<AccessibleMemberInfo> members)
        {
            sb.AppendLine("        public override void SetValueInternal<T>(PAPath path, T value)");
            if (members.Count == 0)
            { 
                sb.AppendLine("            {throw new NotSupportedException(\"No writable properties or fields available for setting value.\");}");
                return;
            }
            sb.AppendLine("        {");
            sb.AppendLine("            PAPart first = path.FirstPart;");
            sb.AppendLine($"            if (first.IsIndex){{throw new NotSupportedException($\"Index access not supported by {nodeType.Name}\");}}");
            sb.AppendLine("            if (path.Parts.Length == 1) {");
            GenerateSinglePathSetterLogic(sb, members);
            sb.AppendLine("            }");
            GenerateMultiPathSetterLogic(sb, members);
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private void GenerateSinglePathSetterLogic(StringBuilder sb, List<AccessibleMemberInfo> members)
        {
            var writableMembers = members.Where(m => m.CanWrite && !m.IsReadOnly).ToList();
            if (writableMembers.Count == 0) return;

            sb.AppendLine("                switch (first.Name)");
            sb.AppendLine("                {");

            foreach (var member in writableMembers)
            {
                sb.AppendLine($"                    case \"{member.Name}\":");
                sb.AppendLine($"                        if (value is {member.Type.ToDisplayString()} _{member.Name}) {{ {member.Name} = _{member.Name};return;}}");
                sb.AppendLine($"                        throw new InvalidCastException($\"Cannot cast {{typeof(T).Name}} to {member.Type.ToDisplayString()}\");");
            }

            sb.AppendLine("                    default:");
            sb.AppendLine("                        throw new NotSupportedException($\"Property '{first.Name}' not found or not writable\");");
            sb.AppendLine("                }");
            sb.AppendLine();
        }

        private void GenerateMultiPathSetterLogic(StringBuilder sb, List<AccessibleMemberInfo> members)
        {
            var multiPathMembers = members.Where(m => (m.HasNestedAccess || m.IsCollection) && m.CanWrite && !m.IsReadOnly).ToList();
            if (multiPathMembers.Count == 0) return;

            sb.AppendLine("               switch (first.Name)");
            sb.AppendLine("               {");

            foreach (var member in multiPathMembers)
            {
                sb.AppendLine($"                   case \"{member.Name}\":");

                if (member.IsCollection)
                {
                    sb.AppendLine("                            if (path.Parts.Length > 1 && path.Parts[1].IsIndex)");
                    sb.AppendLine("                            {");
                    sb.AppendLine($"                                if ({member.Name} != null && path.Parts[1].Index >= 0 && path.Parts[1].Index < {member.Name}.Count)");
                    sb.AppendLine("                                {");
                    sb.AppendLine("                                    if (path.Parts.Length == 2)");
                    sb.AppendLine("                                    {");
                    sb.AppendLine($"                                        if (value is {member.ElementType.ToDisplayString()} itemValue)");
                    sb.AppendLine("                                        {");
                    sb.AppendLine($"                                            {member.Name}[path.Parts[1].Index] = itemValue;");
                    sb.AppendLine("                                            return;");
                    sb.AppendLine("                                        }");
                    sb.AppendLine($"                                        throw new InvalidCastException($\"Cannot cast {{typeof(T).Name}} to {member.ElementType.ToDisplayString()}\");");
                    sb.AppendLine("                                    }");
                    sb.AppendLine("                                    else");
                    sb.AppendLine("                                    {");
                    sb.AppendLine($"                                        var item = {member.Name}[path.Parts[1].Index];");
                    sb.AppendLine("                                        if (item != null)");
                    sb.AppendLine("                                        {");
                    sb.AppendLine("                                            var remainingPath = new PAPath(path.Parts.Skip(2).ToArray());");

                    if (member.ElementType != null && ImplementsIPropertyAccessor(member.ElementType))
                    {
                        sb.AppendLine("                                            ((IPropertyAccessor)item).SetValueInternal<T>(remainingPath, value);");
                    }
                    else
                    {
                        sb.AppendLine("                                            PropertyAccessor.SetValue(item, remainingPath.ToString(), value);");
                    }

                    sb.AppendLine("                                        }");
                    sb.AppendLine("                                    }");
                    sb.AppendLine("                                }");
                    sb.AppendLine("                            }");
                    sb.AppendLine("                            else");
                    sb.AppendLine("                            {");
                    sb.AppendLine($"                                if ({member.Name} != null)");
                    sb.AppendLine("                                {");
                    sb.AppendLine("                                    var remainingPath = new PAPath(path.Parts.Skip(1).ToArray());");
                    sb.AppendLine($"                                    PropertyAccessor.SetValue({member.Name}, remainingPath.ToString(), value);");
                    sb.AppendLine("                                }");
                    sb.AppendLine("                            }");
                }
                else if (member.HasNestedAccess)
                {
                    if (!member.IsValueType)
                    {
                        sb.AppendLine($"                       if ({member.Name} != null)");
                        sb.AppendLine("                       {");
                    }
                    if (member.ImplementsIPropertyAccessor)
                    {
                        sb.AppendLine($"                           {member.Name}.SetValueInternal<T>(path.SkipFirst, value);");
                    }
                    else
                    {
                        sb.AppendLine($"                           PropertyAccessor.SetValue({member.Name}, path.SkipFirst, value);");
                    }
                    sb.AppendLine("                             return;");
                    if (!member.IsValueType)
                    {
                        sb.AppendLine("                       }");
                        sb.AppendLine($"                        throw new NullReferenceException($\"{member.Name} is null\");");
                    }

                }


            }

            sb.AppendLine("                   default:");
            sb.AppendLine("                       throw new NotSupportedException($\"Path starting with '{first.Name}' not supported or not writable\");");
            sb.AppendLine("               }");
            sb.AppendLine();
        }

    }
}