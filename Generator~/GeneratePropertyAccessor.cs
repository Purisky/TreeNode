using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using TreeNodeSourceGenerator;
namespace TreeNodeSourceGenerator
{
    public partial class NodeAccessorSourceGenerator
    {
        private string GeneratePropertyAccessorPartialClass(INamedTypeSymbol nodeType)
        {
            var className = nodeType.Name;
            var namespaceName = nodeType.ContainingNamespace.ToDisplayString();
            var accessibleMembers = AnalyzeAccessibleMembers(nodeType);

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Linq;");
            sb.AppendLine("using TreeNode.Runtime;");
            sb.AppendLine("using TreeNode.Utility;");
            sb.AppendLine();
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            sb.AppendLine($"    public partial class {className} : IPropertyAccessor");
            sb.AppendLine("    {");

            GenerateGetValueInternalMethod(sb, nodeType, accessibleMembers);
            GenerateSetValueInternalMethod(sb, nodeType, accessibleMembers);

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }
        private List<AccessibleMemberInfo> AnalyzeAccessibleMembers(INamedTypeSymbol nodeType)
        {
            var members = new List<AccessibleMemberInfo>();

            foreach (var member in nodeType.GetMembers())
            {
                if (member is IFieldSymbol field && field.DeclaredAccessibility == Accessibility.Public)
                {
                    var memberInfo = AnalyzeFieldMember(field);
                    if (!memberInfo.IsReadOnly && (memberInfo.IsJsonNodeType || memberInfo.ImplementsIPropertyAccessor || memberInfo.HasNestedAccess))
                    {
                        members.Add(memberInfo);
                    }
                }
                else if (member is IPropertySymbol property &&
                         property.DeclaredAccessibility == Accessibility.Public &&
                         property.GetMethod != null)
                {
                    var memberInfo = AnalyzePropertyMember(property);
                    if (!memberInfo.IsReadOnly && (memberInfo.IsJsonNodeType || memberInfo.ImplementsIPropertyAccessor || memberInfo.HasNestedAccess))
                    {
                        members.Add(memberInfo);
                    }
                }
            }

            return members;
        }

        private AccessibleMemberInfo AnalyzeFieldMember(IFieldSymbol field)
        {
            return new AccessibleMemberInfo
            {
                Name = field.Name,
                Type = field.Type,
                IsValueType = field.Type.IsValueType,
                IsJsonNodeType = IsJsonNodeType(field.Type),
                ImplementsIPropertyAccessor = ImplementsIPropertyAccessor(field.Type),
                HasNestedAccess = HasNestedAccessCapability(field.Type),
                IsCollection = IsCollection(field.Type),
                ElementType = GetCollectionElementType(field.Type),
                CanWrite = !field.IsReadOnly,
                IsReadOnly = field.IsReadOnly,
                IsStructCollection = IsStructCollection(field.Type)
            };
        }

        private AccessibleMemberInfo AnalyzePropertyMember(IPropertySymbol property)
        {
            return new AccessibleMemberInfo
            {
                Name = property.Name,
                Type = property.Type,
                IsValueType = property.Type.IsValueType,
                IsJsonNodeType = IsJsonNodeType(property.Type),
                ImplementsIPropertyAccessor = ImplementsIPropertyAccessor(property.Type),
                HasNestedAccess = HasNestedAccessCapability(property.Type),
                IsCollection = IsCollection(property.Type),
                ElementType = GetCollectionElementType(property.Type),
                CanWrite = property.SetMethod != null,
                IsReadOnly = property.SetMethod == null,
                IsStructCollection = IsStructCollection(property.Type)
            };
        }

        private void GenerateGetValueInternalMethod(StringBuilder sb, INamedTypeSymbol nodeType, List<AccessibleMemberInfo> members)
        {
            sb.AppendLine("        public override T GetValueInternal<T>(PAPath path)");
            if (members.Count == 0)
            {
                sb.AppendLine("        {");
                sb.AppendLine("            throw new NotSupportedException(\"No readable properties or fields available for getting value.\");");
                sb.AppendLine("        }");
                return;
            }
            sb.AppendLine("        {");
            sb.AppendLine("            PAPart first = path.FirstPart;");
            sb.AppendLine($"            if (first.IsIndex) {{ throw new NotSupportedException($\"Index access not supported by {nodeType.Name}\"); }}");
            sb.AppendLine("            if (path.Parts.Length == 1)");
            sb.AppendLine("            {");
            GenerateSinglePathGetterLogic(sb, members);
            sb.AppendLine("            }");
            GenerateMultiPathGetterLogic(sb, members);
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private void GenerateSinglePathGetterLogic(StringBuilder sb, List<AccessibleMemberInfo> members)
        {
            sb.AppendLine("                switch (first.Name)");
            sb.AppendLine("                {");

            foreach (var member in members)
            {
                sb.AppendLine($"                    case \"{member.Name}\":");
                sb.AppendLine($"                        return ({member.Name} is T _{member.Name}) ? _{member.Name} : default(T);");
            }
            sb.AppendLine("                    default:");
            sb.AppendLine("                        throw new NotSupportedException($\"Property '{first.Name}' not found\");");
            sb.AppendLine("                }");
        }

        private void GenerateMultiPathGetterLogic(StringBuilder sb, List<AccessibleMemberInfo> members)
        {
            var multiPathMembers = members.Where(m => m.HasNestedAccess || m.IsCollection).ToList();
            if (multiPathMembers.Count == 0) return;

            sb.AppendLine("            switch (first.Name)");
            sb.AppendLine("            {");

            foreach (var member in multiPathMembers)
            {
                sb.AppendLine($"                case \"{member.Name}\":");

                if (member.IsCollection)
                {
                    sb.AppendLine("                    if (path.Parts.Length > 1 && path.Parts[1].IsIndex)");
                    sb.AppendLine("                    {");
                    sb.AppendLine($"                        if ({member.Name} != null && path.Parts[1].Index >= 0 && path.Parts[1].Index < {member.Name}.Count)");
                    sb.AppendLine("                        {");
                    sb.AppendLine($"                            var item = {member.Name}[path.Parts[1].Index];");
                    sb.AppendLine("                            if (item != null)");
                    sb.AppendLine("                            {");
                    sb.AppendLine("                                if (path.Parts.Length == 2)");
                    sb.AppendLine("                                {");
                    sb.AppendLine("                                    return (item is T directValue) ? directValue : default(T);");
                    sb.AppendLine("                                }");
                    sb.AppendLine("                                else");
                    sb.AppendLine("                                {");
                    sb.AppendLine("                                    var remainingPath = new PAPath(path.Parts.Skip(2).ToArray());");

                    if (member.ElementType != null && ImplementsIPropertyAccessor(member.ElementType))
                    {
                        sb.AppendLine("                                    return ((IPropertyAccessor)item).GetValueInternal<T>(remainingPath);");
                    }
                    else
                    {
                        sb.AppendLine("                                    return PropertyAccessor.GetValue<T>(item, remainingPath.ToString());");
                    }

                    sb.AppendLine("                                }");
                    sb.AppendLine("                            }");
                    sb.AppendLine("                        }");
                    sb.AppendLine("                    }");
                    sb.AppendLine("                    else");
                    sb.AppendLine("                    {");
                    sb.AppendLine($"                        if ({member.Name} != null)");
                    sb.AppendLine("                        {");
                    sb.AppendLine("                            var remainingPath = new PAPath(path.Parts.Skip(1).ToArray());");
                    sb.AppendLine($"                            return PropertyAccessor.GetValue<T>({member.Name}, remainingPath.ToString());");
                    sb.AppendLine("                        }");
                    sb.AppendLine("                    }");
                    sb.AppendLine("                    break;");
                }
                else if (member.HasNestedAccess)
                {
                    string content = member.ImplementsIPropertyAccessor?
                    $"return {member.Name}.GetValueInternal<T>(path.SkipFirst);" :
                    $"return PropertyAccessor.GetValue<T>({member.Name}, path.SkipFirst);";
                    string nullCheck = member.IsValueType ? content : $"if ({member.Name} != null) {{ {content} }}";
                    sb.AppendLine($"                    {nullCheck}");
                    if (!member.IsValueType)
                    {
                        sb.AppendLine($"                    throw new NullReferenceException($\"{member.Name} is null\");");
                    }
                }
            }

            sb.AppendLine("                default:");
            sb.AppendLine("                    throw new NotSupportedException($\"Path starting with '{first.Name}' not supported\");");
            sb.AppendLine("            }");
        }

        private void GenerateSetValueInternalMethod(StringBuilder sb, INamedTypeSymbol nodeType, List<AccessibleMemberInfo> members)
        {
            sb.AppendLine("        public override void SetValueInternal<T>(PAPath path, T value)");
            if (members.Count == 0)
            {
                sb.AppendLine("        {");
                sb.AppendLine("            throw new NotSupportedException(\"No writable properties or fields available for setting value.\");");
                sb.AppendLine("        }");
                return;
            }
            sb.AppendLine("        {");
            sb.AppendLine("            PAPart first = path.FirstPart;");
            sb.AppendLine($"            if (first.IsIndex) {{ throw new NotSupportedException($\"Index access not supported by {nodeType.Name}\"); }}");
            sb.AppendLine("            if (path.Parts.Length == 1)");
            sb.AppendLine("            {");
            GenerateSinglePathSetterLogic(sb, members);
            sb.AppendLine("            }");
            GenerateMultiPathSetterLogic(sb, members);
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private void GenerateSinglePathSetterLogic(StringBuilder sb, List<AccessibleMemberInfo> members)
        {
            var writableMembers = members.Where(m => m.CanWrite && !m.IsReadOnly).ToList();
            if (writableMembers.Count == 0) return;

            sb.AppendLine("                switch (first.Name)");
            sb.AppendLine("                {");

            foreach (var member in writableMembers)
            {
                sb.AppendLine($"                    case \"{member.Name}\":");
                sb.AppendLine($"                        if (value is {member.Type.ToDisplayString()} _{member.Name}) {{ {member.Name} = _{member.Name}; return; }}");
                sb.AppendLine($"                        throw new InvalidCastException($\"Cannot cast {{typeof(T).Name}} to {member.Type.ToDisplayString()}\");");
            }

            sb.AppendLine("                    default:");
            sb.AppendLine("                        throw new NotSupportedException($\"Property '{first.Name}' not found or not writable\");");
            sb.AppendLine("                }");
        }

        private void GenerateMultiPathSetterLogic(StringBuilder sb, List<AccessibleMemberInfo> members)
        {
            var multiPathMembers = members.Where(m => (m.HasNestedAccess || m.IsCollection) && m.CanWrite && !m.IsReadOnly).ToList();
            if (multiPathMembers.Count == 0) return;

            sb.AppendLine("            switch (first.Name)");
            sb.AppendLine("            {");

            foreach (var member in multiPathMembers)
            {
                sb.AppendLine($"                case \"{member.Name}\":");

                if (member.IsCollection)
                {
                    sb.AppendLine("                    if (path.Parts.Length > 1 && path.Parts[1].IsIndex)");
                    sb.AppendLine("                    {");
                    sb.AppendLine($"                        if ({member.Name} != null && path.Parts[1].Index >= 0 && path.Parts[1].Index < {member.Name}.Count)");
                    sb.AppendLine("                        {");
                    sb.AppendLine("                            if (path.Parts.Length == 2)");
                    sb.AppendLine("                            {");
                    sb.AppendLine($"                                if (value is {member.ElementType.ToDisplayString()} itemValue)");
                    sb.AppendLine("                                {");
                    sb.AppendLine($"                                    {member.Name}[path.Parts[1].Index] = itemValue;");
                    sb.AppendLine("                                    return;");
                    sb.AppendLine("                                }");
                    sb.AppendLine($"                                throw new InvalidCastException($\"Cannot cast {{typeof(T).Name}} to {member.ElementType.ToDisplayString()}\");");
                    sb.AppendLine("                            }");
                    sb.AppendLine("                            else");
                    sb.AppendLine("                            {");
                    sb.AppendLine($"                                var item = {member.Name}[path.Parts[1].Index];");
                    sb.AppendLine("                                if (item != null)");
                    sb.AppendLine("                                {");
                    sb.AppendLine("                                    var remainingPath = new PAPath(path.Parts.Skip(2).ToArray());");

                    if (member.ElementType != null && ImplementsIPropertyAccessor(member.ElementType))
                    {
                        sb.AppendLine("                                    ((IPropertyAccessor)item).SetValueInternal<T>(remainingPath, value);");
                    }
                    else
                    {
                        sb.AppendLine("                                    PropertyAccessor.SetValue(item, remainingPath.ToString(), value);");
                    }

                    sb.AppendLine("                                }");
                    sb.AppendLine("                            }");
                    sb.AppendLine("                        }");
                    sb.AppendLine("                    }");
                    sb.AppendLine("                    else");
                    sb.AppendLine("                    {");
                    sb.AppendLine($"                        if ({member.Name} != null)");
                    sb.AppendLine("                        {");
                    sb.AppendLine("                            var remainingPath = new PAPath(path.Parts.Skip(1).ToArray());");
                    sb.AppendLine($"                            PropertyAccessor.SetValue({member.Name}, remainingPath.ToString(), value);");
                    sb.AppendLine("                        }");
                    sb.AppendLine("                    }");
                    sb.AppendLine("                    break;");
                }
                else if (member.HasNestedAccess)
                {
                    string content = member.ImplementsIPropertyAccessor?
                    $"{member.Name}.SetValueInternal<T>(path.SkipFirst, value);return;" :
                    $"PropertyAccessor.SetValue({member.Name}, path.SkipFirst, value);return;";
                    string nullCheck = member.IsValueType ? content : $"if ({member.Name} != null) {{ {content} }}";
                    sb.AppendLine($"                    {nullCheck}");
                    if (!member.IsValueType)
                    {
                        sb.AppendLine($"                    throw new NullReferenceException($\"{member.Name} is null\");");
                    }
                }
            }

            sb.AppendLine("                default:");
            sb.AppendLine("                    throw new NotSupportedException($\"Path starting with '{first.Name}' not supported or not writable\");");
            sb.AppendLine("            }");
        }

    }
}