using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using TreeNodeSourceGenerator;
namespace TreeNodeSourceGenerator
{
    public partial class NodeAccessorSourceGenerator
    {
        private string GeneratePropertyAccessorPartialClass(INamedTypeSymbol nodeType,List<AccessibleMemberInfo> accessibleMembers )
        {
            var className = nodeType.Name;
            var namespaceName = nodeType.ContainingNamespace.ToDisplayString();
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Linq;");
            sb.AppendLine("using TreeNode.Runtime;");
            sb.AppendLine("using TreeNode.Utility;");
            sb.AppendLine();
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            string typeKeyword = nodeType.TypeKind == TypeKind.Struct ? "struct" : "class";
            sb.AppendLine($"    public partial {typeKeyword} {className} : IPropertyAccessor");
            sb.AppendLine("    {");

            GenerateGetValueInternalMethod(sb, nodeType, accessibleMembers);
            GenerateSetValueInternalMethod(sb, nodeType, accessibleMembers);

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }
        private List<AccessibleMemberInfo> AnalyzeAccessibleMembers(INamedTypeSymbol nodeType, HashSet<INamedTypeSymbol> propertyAccessorTypes)
        {
            var members = new List<AccessibleMemberInfo>();

            foreach (var member in nodeType.GetMembers())
            {
                if (member is IFieldSymbol field && 
                    field.DeclaredAccessibility == Accessibility.Public &&
                    !field.IsStatic &&
                    !HasJsonIgnoreAttribute(field))
                {
                    var memberInfo = AnalyzeFieldMember(field);
                    if (!memberInfo.IsReadOnly)
                    {
                        members.Add(memberInfo);
                        
                        // 添加符合条件的类型到 propertyAccessorTypes
                        if (memberInfo.HasNestedAccess && 
                            !memberInfo.IsJsonNodeType && 
                            !memberInfo.ImplementsIPropertyAccessor && 
                            !memberInfo.IsCollection &&
                            !memberInfo.Type.IsAbstract&&
                            memberInfo.Type is INamedTypeSymbol namedType&&
                            IsPartial(namedType))
                        {
                            propertyAccessorTypes.Add(namedType);
                        }
                    }
                }
                else if (member is IPropertySymbol property &&
                         property.DeclaredAccessibility == Accessibility.Public &&
                         !property.IsStatic &&
                         property.GetMethod != null &&
                         !HasJsonIgnoreAttribute(property))
                {
                    var memberInfo = AnalyzePropertyMember(property);
                    if (!memberInfo.IsReadOnly)
                    {
                        members.Add(memberInfo);
                        
                        // 添加符合条件的类型到 propertyAccessorTypes
                        if (memberInfo.HasNestedAccess && 
                            !memberInfo.IsJsonNodeType && 
                            !memberInfo.ImplementsIPropertyAccessor && 
                            !memberInfo.IsCollection &&
                            !memberInfo.Type.IsAbstract &&
                            memberInfo.Type is INamedTypeSymbol namedType &&
                            IsPartial(namedType))
                        {
                            propertyAccessorTypes.Add(namedType);
                        }
                    }
                }
            }

            return members;
        }

        private bool HasJsonIgnoreAttribute(ISymbol symbol)
        {
            return symbol.GetAttributes().Any(attr => 
                attr.AttributeClass?.Name == "JsonIgnoreAttribute" ||
                attr.AttributeClass?.ToDisplayString() == "System.Text.Json.Serialization.JsonIgnoreAttribute" ||
                attr.AttributeClass?.ToDisplayString() == "Newtonsoft.Json.JsonIgnoreAttribute");
        }

        private AccessibleMemberInfo AnalyzeFieldMember(IFieldSymbol field)
        {
            return new AccessibleMemberInfo
            {
                Name = field.Name,
                Type = field.Type,
                IsValueType = field.Type.IsValueType,
                IsJsonNodeType = IsJsonNodeType(field.Type),
                ImplementsIPropertyAccessor = ImplementsIPropertyAccessor(field.Type),
                HasNestedAccess = HasNestedAccessCapability(field.Type),
                IsCollection = IsCollection(field.Type),
                ElementType = GetCollectionElementType(field.Type),
                CanWrite = !field.IsReadOnly,
                IsReadOnly = field.IsReadOnly,
                IsStructCollection = IsStructCollection(field.Type)
            };
        }

        private AccessibleMemberInfo AnalyzePropertyMember(IPropertySymbol property)
        {
            return new AccessibleMemberInfo
            {
                Name = property.Name,
                Type = property.Type,
                IsValueType = property.Type.IsValueType,
                IsJsonNodeType = IsJsonNodeType(property.Type),
                ImplementsIPropertyAccessor = ImplementsIPropertyAccessor(property.Type),
                HasNestedAccess = HasNestedAccessCapability(property.Type),
                IsCollection = IsCollection(property.Type),
                ElementType = GetCollectionElementType(property.Type),
                CanWrite = property.SetMethod != null,
                IsReadOnly = property.SetMethod == null,
                IsStructCollection = IsStructCollection(property.Type)
            };
        }
        private bool HasParameterlessConstructor(ITypeSymbol type)
        {
            if (type == null || type.IsAbstract || type.TypeKind != TypeKind.Class)
                return false;

            // 检查是否有公共无参构造函数
            var constructors = type.GetMembers().OfType<IMethodSymbol>()
                .Where(m => m.MethodKind == MethodKind.Constructor &&
                           m.DeclaredAccessibility == Accessibility.Public);

            // 如果没有显式声明构造函数，则有默认的无参构造函数
            if (!constructors.Any())
                return true;

            // 检查是否有无参构造函数
            return constructors.Any(c => c.Parameters.Length == 0);
        }
        private bool NeedCreateInstance(AccessibleMemberInfo member)
        {
            return !member.IsValueType && !member.IsJsonNodeType && HasParameterlessConstructor(member.Type);
        }


        private void GenerateGetValueInternalMethod(StringBuilder sb, INamedTypeSymbol nodeType, List<AccessibleMemberInfo> members)
        {
            bool implementsIPropertyAccessor = ImplementsIPropertyAccessor(nodeType);
            string methodSignature = implementsIPropertyAccessor
                ? "        public override T GetValueInternal<T>(PAPath path)"
                : "        public T GetValueInternal<T>(PAPath path)";
            sb.AppendLine(methodSignature);
            if (members.Count == 0)
            {
                sb.AppendLine("        {");
                sb.AppendLine("            throw new NotSupportedException(\"No readable properties or fields available for getting value.\");");
                sb.AppendLine("        }");
                return;
            }
            sb.AppendLine("        {");
            sb.AppendLine("            PAPart first = path.FirstPart;");
            sb.AppendLine($"            if (first.IsIndex) {{ throw new NotSupportedException($\"Index access not supported by {nodeType.Name}\"); }}");
            sb.AppendLine("            if (path.Parts.Length == 1)");
            sb.AppendLine("            {");
            GenerateSinglePathGetterLogic(sb, members);
            sb.AppendLine("            }");
            GenerateMultiPathGetterLogic(sb, members);
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private void GenerateSinglePathGetterLogic(StringBuilder sb, List<AccessibleMemberInfo> members)
        {
            sb.AppendLine("                switch (first.Name)");
            sb.AppendLine("                {");

            foreach (var member in members)
            {
                sb.AppendLine($"                    case \"{member.Name}\":");
                if (NeedCreateInstance(member))
                {
                    sb.AppendLine($"                        {member.Name}??=new();");
                }
                sb.AppendLine($"                        return ({member.Name} is T _{member.Name}) ? _{member.Name} : default(T);");
            }
            sb.AppendLine("                    default:");
            sb.AppendLine("                        throw new NotSupportedException($\"Property '{first.Name}' not found\");");
            sb.AppendLine("                }");
        }

        private void GenerateMultiPathGetterLogic(StringBuilder sb, List<AccessibleMemberInfo> members)
        {
            var multiPathMembers = members.Where(m => m.HasNestedAccess || m.IsCollection).ToList();
            if (multiPathMembers.Count == 0)
            {
                if (members.Any())
                {
                    sb.AppendLine("            throw new NotSupportedException(\"No multi-path properties or fields available for getting value.\");");
                }
                return;
            }

            sb.AppendLine("            switch (first.Name)");
            sb.AppendLine("            {");

            foreach (var member in multiPathMembers)
            {
                sb.AppendLine($"                case \"{member.Name}\":");

                if (member.IsCollection)
                {
                    sb.AppendLine($"                        {member.Name}??=new();");
                    sb.AppendLine($"                        return {member.Name}.GetValueInternal<T>(path.SkipFirst);");
                }
                else if (member.HasNestedAccess)
                {
                    bool needCreateInstance = NeedCreateInstance(member);
                    if (needCreateInstance)
                    {
                        sb.AppendLine($"                        {member.Name}??=new();");
                    }
                    string content = member.ImplementsIPropertyAccessor?
                    $"return {member.Name}.GetValueInternal<T>(path.SkipFirst);" :
                    $"return PropertyAccessor.GetValue<T>({member.Name}, path.SkipFirst);";
                    string nullCheck = member.IsValueType|| needCreateInstance ? content : $"if ({member.Name} != null) {{ {content} }}";
                    sb.AppendLine($"                    {nullCheck}");
                    if (!member.IsValueType&&!needCreateInstance)
                    {
                        sb.AppendLine($"                    throw new NullReferenceException($\"{member.Name} is null\");");
                    }
                }
            }

            sb.AppendLine("                default:");
            sb.AppendLine("                    throw new NotSupportedException($\"Path starting with '{first.Name}' not supported\");");
            sb.AppendLine("            }");
        }

        private void GenerateSetValueInternalMethod(StringBuilder sb, INamedTypeSymbol nodeType, List<AccessibleMemberInfo> members)
        {
            bool implementsIPropertyAccessor = ImplementsIPropertyAccessor(nodeType);
            string methodSignature = implementsIPropertyAccessor
                ? "        public override void SetValueInternal<T>(PAPath path, T value)"
                : "        public void SetValueInternal<T>(PAPath path, T value)";
            sb.AppendLine(methodSignature);
            if (members.Count == 0)
            {
                sb.AppendLine("        {");
                sb.AppendLine("            throw new NotSupportedException(\"No writable properties or fields available for setting value.\");");
                sb.AppendLine("        }");
                return;
            }
            sb.AppendLine("        {");
            sb.AppendLine("            PAPart first = path.FirstPart;");
            sb.AppendLine($"            if (first.IsIndex) {{ throw new NotSupportedException($\"Index access not supported by {nodeType.Name}\"); }}");
            sb.AppendLine("            if (path.Parts.Length == 1)");
            sb.AppendLine("            {");
            GenerateSinglePathSetterLogic(sb, members);
            sb.AppendLine("            }");
            GenerateMultiPathSetterLogic(sb, members);
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private void GenerateSinglePathSetterLogic(StringBuilder sb, List<AccessibleMemberInfo> members)
        {
            var writableMembers = members.Where(m => m.CanWrite && !m.IsReadOnly).ToList();
            if (writableMembers.Count == 0) return;

            sb.AppendLine("                switch (first.Name)");
            sb.AppendLine("                {");

            foreach (var member in writableMembers)
            {
                sb.AppendLine($"                    case \"{member.Name}\":");
                if (NeedCreateInstance(member))
                {
                    sb.AppendLine($"                        {member.Name}??=new();");
                }
                sb.AppendLine($"                        if (value is {member.Type.ToDisplayString()} _{member.Name}) {{ {member.Name} = _{member.Name}; return; }}");
                sb.AppendLine($"                        throw new InvalidCastException($\"Cannot cast {{typeof(T).Name}} to {member.Type.ToDisplayString()}\");");
            }

            sb.AppendLine("                    default:");
            sb.AppendLine("                        throw new NotSupportedException($\"Property '{first.Name}' not found or not writable\");");
            sb.AppendLine("                }");
        }

        private void GenerateMultiPathSetterLogic(StringBuilder sb, List<AccessibleMemberInfo> members)
        {
            var multiPathMembers = members.Where(m => (m.HasNestedAccess || m.IsCollection) && m.CanWrite && !m.IsReadOnly).ToList();
            if (multiPathMembers.Count == 0)
            {
                if (members.Any())
                {
                    sb.AppendLine("            throw new NotSupportedException(\"No multi-path properties or fields available for setting value.\");");
                }
                return;
            }

            sb.AppendLine("            switch (first.Name)");
            sb.AppendLine("            {");

            foreach (var member in multiPathMembers)
            {
                sb.AppendLine($"                case \"{member.Name}\":");

                if (member.IsCollection)
                {
                    sb.AppendLine($"                        {member.Name}??=new();");
                    if (member.IsStructCollection)
                    {
                        sb.AppendLine($"                        {member.Name}.SetValueInternalStruct(path.SkipFirst, value);");
                    }
                    else
                    {
                        sb.AppendLine($"                        {member.Name}.SetValueInternalClass(path.SkipFirst, value);");
                    }
                    sb.AppendLine("                        return;");
                }
                else if (member.HasNestedAccess)
                {
                    bool needCreateInstance = NeedCreateInstance(member);
                    if (needCreateInstance)
                    {
                        sb.AppendLine($"                        {member.Name}??=new();");
                    }
                    string content = member.ImplementsIPropertyAccessor ?
                    $"{member.Name}.SetValueInternal<T>(path.SkipFirst, value);return;" :
                    $"PropertyAccessor.SetValue({member.Name}, path.SkipFirst, value);return;";
                    string nullCheck = member.IsValueType|| needCreateInstance ? content : $"if ({member.Name} != null) {{ {content} }}";
                    sb.AppendLine($"                    {nullCheck}");
                    if (!member.IsValueType&&!needCreateInstance)
                    {
                        sb.AppendLine($"                    throw new NullReferenceException($\"{member.Name} is null\");");
                    }
                }
            }

            sb.AppendLine("                default:");
            sb.AppendLine("                    throw new NotSupportedException($\"Path starting with '{first.Name}' not supported or not writable\");");
            sb.AppendLine("            }");
        }

    }
}